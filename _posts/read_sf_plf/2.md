#### 汇编编译程序
==伪指令==
==assume cs:codesg==
==codesg segment==
		汇编指令
		 mov ax,4c00h
		 int 21h   //作用相当于return 0
==codesg ends==
==end==
assume（假设）
假设cs和codesg相关联 
段名 segment //段的开始
段名 ends //段的结束
end //汇编结束标记

----
#### 由源程序到执行可执行文件的过程
源程序文件 .asm （汇编指令等语言）
目标文件.obj  （经编译器编译后的源程序，机器指令）
可执行文件 .exe  （连接形成，相关描述信息+机器指令的文件）
.lst 列表文件，编译器将源程序编译为目标文件过程中产生的结果
.crf  交叉引用文件，编译器将源程序编译为目标文件过程中产生的结果

.map （映像文件）连接程序将目标文件连接为可执行文件过程中的中间结果
.lib（库文件） 包含了一些可以调用的子程序

---
#### 用debug装载程序
debug 名.exe
-p 类似t命令，逐条执行命令，显示结果 但遇到子程序，中断时，直接执行显示结果
-g 从指定地址处开始运行程序，直到遇到断点或程序正常结束
在debug中运行，command加载debug.exe，debug将程序加载入内存，执行完返回到debug，通过-q退出debug返回到command
在dos中运行，计算机由命令解释器控制，运行可执行程序时，comman将程序加载入内存，设置cpu的cs：ip指向程序的第一条指令，使程序运行，程序结束后返回到命令解释器，cpu继续运行command

---
#### loop指令
指令格式 loop标号
(cx)=(cx)-1;
判断cx中的值 不为零则转至标号处执行程序
如果为零则向下执行
注意：汇编源程序时，数据不能以字母开头，要在fffff前加0
示例:
`assume cs:code`
`code segment`
	`mov ax,2`
	`mov cx,11`
`s:      add ax,ax`
	`loop s`
	`mov ax,4c00h`
	`int 21h`
`code ends`
`end`

---
#### 段前缀的使用
mov al,[0] 在debug可以正常使用，但是不可以在源代码中直接使用，否则会直接将0赋值
此时需要加上段前缀 mov al,ds:[0]
es 为附加段寄存器

---
#### 在代码段中使用数据
dw  0123H,0456H,0789H 在代码段中定义数据
dw  定义一个字
db   定义一个字节
dd   定义一个双字
但是这样会让cs的偏移地址出现问题，所以引入start
`assume cs:code`
`code segment`
	`dw 0123H,0456H`
`start: mov bx,0`
	`mov ax,0`
   `s: add ax,cs:bx`
    `add bx,2`
    `loop s`
    `mov ax,4c00h`
     `int 21h`
     `ZmxhZ3swS195MHVfZzN0XzF0fQ==`
`code ends`
`end start`
start: 定义一个标号，指示代码开始的位置（在end后随意定义）
end start 除了通知编译器程序结束外，还可通知编译程序入口在什么地方

#### 在代码段中使用栈
`assume cs:code`
`code segment`
	`dw 0123H,0456H`
	`dw 0,0,0,0`
`start: mov ax,cs`
	`mov ss,ax //栈默认以字节处理，设置栈顶段地址`
	`mov sp,30h//设置栈顶偏移地址，注意汇编没有栈底，初始设置的栈顶即为栈底`
	`mov bx,0`
	`mov cx,8`
`s:      push cs:[bx]`
	`add bx,2`
	`loop s`
	`mov bx,0`
	`mov cx,8`
`s0:     pop cs:[bx]`
	`add bx,2`
	`loop s0`
	mov ax 4c00h
	int 21h
	code ends
	end start

---
#### 将数据，代码，栈放入不同段
assume cs:code,ds:data,ss:stack
data segment
   dw 0123H,0456H
data ends
stack segment
   dw 0,0,0,0
stack ends
code segment
start :
   mov ax,stack
   mov ss,ax
   mov sp,20h
   mov ax,data
   mov ds,ax  ;初始化各段寄存器,程序至少有一个代码段，会给代码段地址寄存器cs自动赋值
	mov bx,0
	mov cx,8
s:     push [bx];没有写段地址，默认段地址为ds
	add bx,2
	loop s
   ;入栈
   ;出栈
   mov ax,4c00h
   int 21h
code ends
end start