rip 返回报错地址
rsp 栈顶指针
rbp 栈底指针
sub 减

---
movsxd r64, r/m32`
    
- 意思是：**把32位有符号数，符号扩展成64位，然后放到目标寄存器里**
- ### unsigned int → movsxd → 被误当作负数

`unsigned int index = 0xFFFFFFFF; // 实际是 4294967295 
array[index]; // 看起来合法（unsigned）  // 
但反编译时用 movsxd 扩展为 rax = -1 
movsxd rax, edi 
mov  rbx, [array + rax*4] ; 实际访问 array[-1]

---
jns 如果结果是非负数就跳转


### `dword` 是什么？

- 在 x86 汇编中，`dword` 是一个数据类型的大小说明符，表示 4 字节（32 位）。
    
- 它可以用于表示：
    
    - 一个 32 位整数（无符号或有符号）
        
    - 一个地址（指针，在 32 位系统中地址本身就是 4 字节）
    
    **在 C++ 中，如何从字符串中一次读取 4 个字节（比如像 `v4 = *(_DWORD *)&Str[4 * i];` 这样）？**

>你追求的效果是：**将字符串当成原始内存，按 4 字节（即 `uint32_t`）一组读取。**
>
>常用**uint32_t v4 = *(uint32_t*)(str.data() + 4 * i);**
 
 `&Str[4 * i + 4]`
- 这个取地址操作使得它变成了一个指针：**指向内存中第 `4*i + 4` 个字节的位置**；
- 即拿到了第 `i` 块的第二个 dword 的首地址。
`( _DWORD * ) &Str[4 * i + 4]`
- 这表示把这个地址强制转换为 `uint32_t*`（即指向一个 4 字节整数）；  
- 也就是你假设从这地方开始的连续 4 字节构成一个无符号整型；

std::string str = "ABCDEFGH";
const char* p = str.data();
这会返回指向 str 内部存储内容的一个指针，p 的类型是 const char*