流程转移和子程序
mov ax, bx 占2字节
mov al, 1 占 2 字节（操作码是 `B0`，立即数是 1 字节）
mov ax, 1 占用 **3 个字节**（1 字节操作码 + 2 字节立即数）

操作符offset(取得标号的偏移地址)
格式：
offset 标号
assume cs:code
code segment
start:  mov ax,offset start ;相当于mov ax,0
	s: mov ax,offset s ;相当于mov ax,3
		mov si,offset s
		mov di,offset s0
		mov ax,cs:[si] //若不加cs，会自动默认为data段
		mov cs:[di],ax
	s0:
		nop
		nop//空指令，机器码占一个字节，起到占位作用
		code ends
		end

---
jmp指令
无条件转移
jmp指令功能：无条件转移，可以只修改IP，也可以同时修改CS和IP
jmp指令要给的信息：1.转移的目的地址
2.转移的距离
段间转移（远转移）：jmp 2000:1000
段内短转移：jmp short 标号；修改范围-128~127 8位转移
段内近转移： jmp near ptr 标号 ；ip修改范围为-32768~32767 ，16位转移

短转移位移产生=标号处的地址-jmp指令后的第一个字节的地址
近转移同理 

远转移指明要跳转到的目的地址 ，即包含了标号的段地址cs和偏移地址IP

jmp word ptr 内存单元地址（段内转移）
功能：内存单元地址处开始存放一个字，是转移的目的偏移地址
 
 jmp dword ptr  内存单元地址（段间转移）
 从内存单元地址开始存放着两个字，高地址处的字是转移的目的端地址，低地址是转移的目的偏移地址
jmp 标号
jmp 寄存器
jmp 内存单元（表示跳转到的地址）
例如 jmp dword ptr [bx]

---
各种指令
jcxz 标号
如果(cx)=0,转移到标号处执行
(cx)不等于0时，继续向下执行

- - **ZF（Zero Flag）= 0** → 表示“不相等”
        
    - **SF（Sign Flag）= 0** → 表示结果为正数
        
    - **CF（Carry Flag）= 0** → 无借位（说明 ax ≥ 5）
        
    - **OF（Overflow Flag）= 0** → 没有溢出

调用子程序：call指令（将当前ip或cs、ip压入栈中，转移到标号处执行指令 ）
返回：ret指令（用栈中的数据，修改IP的内容，实现近转移，pop IP）retf 修改cs和IP，远转移 
  
mul指令
八位乘法，被乘数默认放在al，乘数放在8位寄存器或内存单元，结果AX（16位）。
16位乘法，16位寄存器或内存字单元，结果高位放在DX，低位放在AX

---
模块化设计
参数存储位置与计算数值存储位置
1.用寄存器传递参数 mov bx，n
2.用内存单元进行参数传递
3.用栈传递参数

标志寄存器：PSW/FLAGS（用来存储相关指令的某些执行结果，控制cpu相关工作方式）
别称：程序状态字

---
串传送指令
movsb ：以字节为单位传送 （(es) * 16+(di)）=((ds) * 16+(si))

movsw：以字为单位传送

若DF=0，操作后，si和di递增
DF=1，操作后，si和di递减
cld，将DF设为0 ； std，将DF设为1

rep指令
rep指令常和串传送指令搭配使用，可根据cx的值，重复执行后面的指令